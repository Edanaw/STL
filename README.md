# STL
C++标准模板库STL的学习

## 泛型编程
针对一个或多个尚未明确的类型而编写的一个个函数, 是C++的一个新特性
通过引入模板，C++引申出了泛型编程技术，简单的理解泛型编程就是使用该技术编写的代码可以适用于多种数据类型。

在支持C++模板的基础上, 程序员们编写出很多针对不同数据类型的算法，其中STL成为C++的标准程序库

## STL的基本组成
STL是由容器、算法、迭代器、函数对象、适配器、内存分配器6部分组成
|STL的组成|含义|
|---|---|
|容器|一些封装数据结构的模板类，例如 vector 向量容器、list 列表容器等。|
|算法|STL 提供了非常多（大约 100 个）的数据结构算法，它们都被设计成一个个的模板函数，这些算法在 std 命名空间中定义，其中大部分算法都包含在头文件 <algorithm> 中，少部分位于头文件 <numeric> 中。|
|迭代器|在 C++ STL 中，对容器中数据的读和写，是通过迭代器完成的，扮演着容器和算法之间的胶合剂。|
|函数对象|如果一个类将 () 运算符重载为成员函数，这个类就称为函数对象类，这个类的对象就是函数对象（又称仿函数）。|
|适配器|可以使一个类的接口（模板的参数）适配成用户指定的形式，从而让原本不能在一起工作的两个类工作在一起。值得一提的是，容器、迭代器和函数都有适配器。|
|内存分配器|为容器类模板提供自定义的内存申请和释放功能，由于往往只有高级用户才有改变内存分配策略的需求，因此内存分配器对于一般用户来说，并不常用。|


> C++ 标准重新组织为13个文件 
<iterator><functional><vector><deque><list><queue><stack><set><map><algorithm><numeric><memory><utility>

## STL 容器
容器其实就是一些模板类的集合，和普通模板类不同的是，容器中封装的是组织数据的方法(数据结构)。STL提供了3类标准容器，分别是序列式容器、排序容器和哈希容器，后面
两种容器也成为关联容器

|容器种类|功能|
|---|---|
|序列容器|主要包括vector向量容器、list列表容器、deque双端队列容器、之所以称为是序列容器，是因为容器不是排序的, 元素在插入容器的时候，指定在什么位置就是什么位置|
|排序容器|包括set集合容器、multiset多重集合容器、map映射容器、multimap多重映射容器，排序容器的元素默认是由小到大排列的，即便是插入元素，元素也会插入到适当的位置|
|哈希容器|C++11新增加的4种关联式容器，分别是unordered_set 哈希集合、unordered_multiset 哈希多重集合、unordered_map 哈希映射以及 unordered_multimap 哈希多重映射。哈希容器中的元素是未排序的，元素的位置由哈希函数决定|

### STL 迭代器
迭代器就是用来遍历容器中存储的元素。
利用泛型技术，设计的一种可以将容器和算法分离的东西，实现此目的需要一种中介的装置，他除了具有对容器的便利读写的能力外，还能对外隐藏容器的内部差异，从而统一的界面算法
向外界传送数据，通过迭代器可以指向容器中的某个元素，也可以对该元素进行读写操作

STL为每一种容器都设计了一种迭代器类型，所以不同容器的迭代器功能也不相同
> 容器的迭代器功能强弱也决定了该容器是否支持STL中的某种算法

常用的迭代器按照功能强弱分为输入迭代器、输出迭代器、前向迭代器、双向迭代器、随机访问迭代器5种，目前主要讲解后面的三种
> 输入和输出迭代器比较特殊, 他们不是吧数组或者容器当作操作对象，而是把输入流/输出流当作操作对象。

1. 前向迭代器支持的操作， ++p、--p、*p操作，还可以被复制或赋值，也可以用==或!=运算符进行比较。两个正向迭代器可以互相赋值
2. 双向迭代器具有正向迭代器的全部功能, 除此之外，假设p是一个双向迭代器还可以进行--p和p--操作
3. 随机访问迭代器：随机访问迭代器具有双向迭代器的所有功能，初次之外还有如下的功能，假设p是一个迭代器，i是一个整形变量
- p+=i
- p-=i
- p+i
- p-i
- p[i] 
除此之外两个随机访问迭代器p1、p2还可以用比较运算符进行比较

如下是C++11标准指定的不同容器使用的迭代器类型
|容器|对应的迭代器类型|
|---|---|
|array|随机访问迭代器|
|vector|随机访问迭代器|
|deque|随机访问迭代器|
|list|	双向迭代器|
|set/multiset| 双向迭代器|
|map/multimap| 双问迭代器|
|forward_list| 前向迭代器|
|unordered_map / unordered_multimap| 前向迭代器|
|unordered_set / unordered_multiset| 前向迭代器|
|stack|不支持迭代器|
|queue|不支持迭代器|

> 注意，容器适配器 stack 和 queue 没有迭代器，它们包含有一些成员函数，可以用来对元素进行访问。

### 序列式容器
说明：按照线性排列的方式存储某一制定类型的数据，该容器不会自动对存储的元素进行排序
包括以下几类容器:
- array<T, N>: 数组容器，长度一旦建立不可更改
- vector<T>：向量容器，长度可以更改，在尾部增加和删除元素的效率最高O(1), 其他位置的效率差O(n)
- deque<T>：双端队列容器, 在头部个尾部插删除元素的效率都高O(1)
- list<T>: 链表容器, 是一个双向链表，在任意位置都可以高效的插入和删除元素，但是访问容器中任意元素的速度要比上面三种慢
- forward_list<T>: 正向链表容器，是以单链表的形式组织元素，比链表元素要省内存

> stack<T> 和 queue<T> 本质上也属于序列容器，只不过它们都是在 deque 容器的基础上改头换面而成，通常更习惯称它们为容器适配器

array容器是可以进行大小比较的操作
```C++
#include <iostream>
#include <array>
using namespace std;
int main()
{
    array<char, 50> addr1{ "http://c.biancheng.net" };
    array<char, 50> addr2{ "http://c.biancheng.net/stl" };
    if (addr1 == addr2) {
        std::cout << "addr1 == addr2" << std::endl;
    }
    if (addr1 < addr2) {
        std::cout << "addr1 < addr2" << std::endl;
    }
    if (addr1 > addr2) {
        std::cout << "addr1 > addr2" << std::endl;
    }
    return 0;
}

运行结果为：addr1 < addr2
```
